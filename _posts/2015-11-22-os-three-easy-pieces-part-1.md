---
layout:		post
comments:	true
title:		"Конспект. Операционные системы. Часть 1. Виртуализация"
date:		2015-11-22
categories:
- workbook
- OS
---
ОС предоставляет API для процессов. В Unix используется комбинация 2х системных вызовов - **fork()** & **exec()**.

Виртуализация CPU
--
ОС контролирует, то, что исполняется в текущий момент тем самым, организовывая Limited Direct Execution.
Для того, чтобы это работало, требуется небольшая поддержка со стороны железа, в виде специального прерывания(trap), и в момент загрузки, ОС устанавливает так называемый **trap handler**, т.е. обработчик прерываний, в котором ОС как раз и проверяет права на запуск.

Как только процесс запущен, возникает необходимость работы нескольких процессов одновременно. ОС создает иллюзию того, что все работает одновременно, а на самом деле используется так называемый кооперативный режим, при котором, каждый процесс исполняется только слайс времени.
Для того, чтобы это заработало, ОС прерывается по заданному таймеру, который предоставляется железом (для этого необходимо установить **timer interrupt handler**), и выполняет переключение контекста (**context switch**), в котором выполнение передается другому процессу.
Само переключение контекста чаще всего означает сохранение всех необходимых регистров текущего процесса.
Так появляется задача, эффективного планирования и распределения слайсов времени т.е. **CPU Scheduling**, а также, зарождается многопоточность на уровне ядра ОС.

Виртуализация памяти.
--

В любой программе есть 3 адресных пространства: **code**, **stack**, **heap**. В задачу ОС входит расположение выше обозначенных сегментов в памяти, а также предоставление API для работы с ними. На уровне ОС чаще всего предоставляются 2 функции - **malloc()** & **free()**, которые позволяет выделить и освободить место на куче(heap). Главная сложность, которая при этом возникает - это как расположить эти участки наиболее эффективно т.е. с минимальным количеством потраченного в пустую места. Существует несколько подходов: сегментация и постраничная организация памяти, при этом в настоящий момент используется комбинация сегментации и постраничной организации памяти. Сегментации присущи проблемы фрагментации, которая бывает внутренней(на уровне malloc) и внешней(на уровне ОЗУ), а постраничная организация в первом исполнение требует большое количество памяти, для хранения структуры страниц. Поэтому в качестве решения используется сегментная организация страниц т.е. каждый сегмент, содержит таблицы переходов для страниц тем самым организовывая многоуровневую структуру страниц.

В реальной жизни, количество оперативной памяти ограничено, а также, каждая программа должна иметь доступ, только к определенным участкам памяти, таким образом зарождается задача  виртуализации памяти т.е. предоставления иллюзии того, что у нас достаточно много памяти(в идеальном случае бесконечно много), а также организация контроля над доступом к памяти.

Для виртуализации памяти, ОС предоставляет для каждой программы не настоящий адрес, а виртуальный адрес, который необходимо транслировать в реальный адрес при каждом доступе. При трансляции проверяются права доступа к участку памяти, а также валидность самого адреса. В ходе этого могут возникнуть **PAGE FAULT**(т.е. ошибка доступа к странице, чаще всего означает не валидный адрес) и **PROTECTION FAULT**(т.е. недостаток прав доступа к указанной странице). Так как в целом указанный выше процесс достаточно медленный, то используется кеш, либо на уровне железа, либо на уровне софта и называется TLB(Translation Lookaside Buffer), поэтому важно, чтобы доступ к памяти велся постранично т.е. минимизировать количество cache miss.

Для того чтобы создать иллюзию бесконечной памяти, используется swapping т.е. при недостатки памяти, некоторые страницы выгружается на специальный swap-раздел жесткого диска и помечаются как **NA**. Так как доступ к жесткому диску в десятки раз медленней доступа к памяти, то стоит задача минимизировать количество этих обращений. Для этого необходимо решить какие страницы необходимо выгружать на диск(наименее часто используемые), а какие загружать в память(наиболее часто используемые).