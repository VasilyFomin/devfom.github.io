---
layout:		post
comments:	true
title:		"Aссемблер для Linux: режимы доступа к данным"
date:		2015-05-02
categories:
- linux
- asm
---

Любая программа так или иначе оперирует данным, о том, какие способы доступа к данным есть в ассемблере и пойдет речь в данной записке.

Общая форма доступа к данным в ассемблере(все поля опциональны):

{% highlight asm %}
ADDRESS_OR_OFFSET(%BASE_OR_OFFSET,%INDEX,MULTIPLIER)
{% endhighlight %}

#### Immediate mode
Режим при котором, данные, к которым CPU должен получить доступ встраиваются непосредственно в инструкцию. Например, если мы хотим инициализировать регистр значением `0` мы выберем данный режим и просто передадим нужные данные.
Этот режим не следует общей формы, и для активации нужно добавить символ $ перед данными.

Например, для записи `12` в регистр `%eax`:

{% highlight asm %}
movl $12, %eax
{% endhighlight %}

#### Direct addressing mode
Режим при котором инструкция содержит адрес памяти, из которого нужно загрузить данные. Например, для инициализации регистра мы можем использовать адрес `200` и CPU возьмет данные оттуда и загрузит их в регистр. 

Реализовано в ассемблер используя `ADDRESS_OR_OFFSET` часть базовой формы:

{% highlight asm %}
movl ADDRESS_OR_OFFSET, %eax
{% endhighlight %}

#### Indexed addressing mode
При этом режиме инструкция содержит адрес памяти, по которому нужно произвести чтение, а также определяет `индексный регистр`, который нужно использовать для смещения этого адреса. Например, используя адрес `2002` и индексный регистр `4`, данные будут загружены по адресу `2006`. И это оказывается удобным для итерации по набору данных, которые начинаются адресу `2002`. 
При этом `x86` процессоры позволяют также задать множитель для индексного регистра, тем самым позволяя итерироваться по байтам и словам(4 байта). Например, для доступа к 4 **байту**, начиная с `2002` нужно загрузить `3` в индексный регистр, и установить `1` в множитель. А для доступа к 4-му **слову**, начиная с адреса `2002` нужно использовать множитель 4, тем самым получив адрес `2014`.

Реализовано в ассемблер используя `ADDRESS_OR_OFFSET` и `%INDEX%` из базовой формы. Например, для того чтобы загрузить 4-х байтовый `data_item` в регистр `%eax` по индексу установленному в регистре `%ecx`:

{% highlight asm %}
movl data_items(, %ecx, 4), %eax 
{% endhighlight %}

#### Indirect addressing mode
При этом режиме инструкция содержит регистр, который содержит указатель, по которому нужно загрузить необходимые данные. Например, если указать регистр `eax`, который содержит 4, то в данном случае 4 будет использоваться как указатель, на область по памяти, по которой находятся нужные нам данные. Т.е. главное отличие от direct addressing mode заключается в том, что в данном случае мы интерпретируем число 4 как указатель, в то время как в первом случае 4 - это запрашиваемые данные.

Например, для того чтобы загрузить данные, по указателю, на который указывает регистр `%eax` в регистр `%ebx` используется следующая форма:

{% highlight asm %}
movl (%eax), %ebx
{% endhighlight %}

#### Base pointer addressing mode
Режим похож на indirect addressing mode, только добавляется возможность указывать смещение, для значения прочитанного из регистра. Разница заключается в том, что в данном режиме смещение остается постоянным и меняется указатель, а в предыдущем - указатель остается неизменным, и изменяется смещение.

Например, если `%eax` хранит указатель на какую-то структуру, в которой есть 2 поля размером 4 байта, то для чтения 2-го поля в регистр `%ebx` используется следующая запись:

{% highlight asm %}
movl 4(%eax), %ebx
{% endhighlight %}

#### Примеры
В книге рассматривается программа, для поиска максимального элемента в списке, конец которого обозначается нулем:

{% highlight asm %}
# %edi - текущий индекс
# %ebx - максимальное значение
# %eax - текущий элемент
.section .data
# Исходный список
data_items:
    .long 3,67,34,222,45,75,54,34,44,33,22,11,66,0

.section .text
.globl _start
_start:
    # Записываем начальное значение индекса(0) в edi
    movl $0, %edi
    # Записываем в eax значение элемента по текущему индексу - 3
    movl data_items(, %edi, 4), %eax
    # Так как это первый элемент, устанавливаем его как текущий максимум
    movl %eax, %ebx

    # Цикл по всему списку
    start_loop:
        # Если текущее значение eax равно нулю - выходим из программы
        cmpl $0, %eax
            je loop_exit
        # Увеличиваем значение индекса
        incl %edi
        # Записываем в eax значение элемента по текущему индексу
        movl data_items(, %edi, 4), %eax
        # Если текущее значение в eax меньше или равно текущему максиму - возвращаемся в начало цикла
        cmpl %ebx, %eax
            jle start_loop
        # Иначе обновляем значение максимума и возвращаемся в начало цикла
        movl %eax, %ebx
        jmp start_loop

    loop_exit:
        movl $1, %eax
        int $0x80
{% endhighlight %}

В качестве одного из упражнений предлагается использовать указатель на конец списка, в качестве условия окончания итерирования. Решение пришлось поискать, потому что так сходу сам и не сообразил, но решение все равно приведу т.к оно показывает, как еще можно использовать `immediate mode`:

{% highlight asm %}
# %edi - index
# %ebx - largest so far
# %eax - current item
.section .data
# Исходный список
data_items:
    .long 3,67,34,222,45,75,54,34,44,33,22,11,66
# Отмечаем конец списка
data_end:

.section .text
.globl _start
_start:
    movl $0, %edi
    movl data_items(, %edi, 4), %eax
    movl %eax, %ebx

    start_loop:
        incl %edi
        # Умножаем текущий индекс на размер элементов списка(4) и сохраняем в eax
        imul $4, %edi, %eax
        # Смещаем начальный адрес списка на рассчитанное смещение
        addl $data_items, %eax
        # Если полученный адрес равен конце списка - выходим из программы
        cmpl $data_end, %eax
            je loop_exit

        movl data_items(, %edi, 4), %eax
        cmpl %ebx, %eax
            jle start_loop
        movl %eax, %ebx
        jmp start_loop

    loop_exit:
        movl $1, %eax
        int $0x80
{% endhighlight %}

В программе используется тот факт, что элемент в `.data` секции, представляют собой таблички, указывающие на адрес области памяти, соответствующий скрытыми за ними данными, и если использовать `immediate mode` т.е. применить `$` к этой таблички, то мы получаем адрес.
