---
layout:		post
comments:	true
title:		"Aссемблер для Linux: функции"
date:		2015-05-05
categories:
- linux
- asm
---

В данном посте речь пойдет о том, как реализуются функции в ассемблере, о том что такое соглашение о вызовах(calling conventions), и какую роль в этом играет стек.

### Стек
Ассемблер имеет встроенную поддержку такой структуры данных, как стек, почему это очень важно, можно узнать в следующем разделе, а пока базовые принципы работы со стеком в ассемблере.

В ассемблере стек представлен регистром `%esp`, который хранит указатель на вершину стека. Для того чтобы добавить элемент в стек используется инструкция `pushl`, а для удаления `popl`. Важно помнить, что стек растет вверх, а память вниз т.е,  если мы добавляем новый элемент в стек, то из значения `%esp` вычитается 4(размер слова), а если удаляем, то соответственно к значению прибавляется 4.

Для того чтобы получить текущее значение вершины стека, используется indirect addressing mode:

{% highlight asm %}
movl (%esp), %eax
{% endhighlight %}

Если бы мы использовали direct addressing mode, то `%eax` бы содержал адрес вершины стека:

{% highlight asm %}
movl %esp, %eax
{% endhighlight %}

А для того чтобы получить элемент, следующий за вершиной стека, можно использовать base addressing mode, в котором мы добавляем нужное смещение, и тем самым двигаемся вниз по стеку:

{% highlight asm %}
movl 4(%esp), %eax
{% endhighlight %}

### Соглашение о вызовах, или как работают функции в Си
А теперь самое интересное, то, о чем, я давно хотел узнать - как работают функции в Си. Существует такое понятие как соглашение о вызове(calling convention), которое говорит о том, в каких регистрах и что хранится, и стек играет в этом ключевую роль, позволяя сохранить локальные переменные, адрес возврата, и переданные перменные.

#### До вызова
Перед вызовом функции, все ее параметры помещаются в стек в **обратном** порядке, затем, для вызова функции используется инструкция `call`, которая делает 2 вещи:

1. Добавляет адрес следующей инструкции в стек(адрес возврата)
2. Изменяет регистр instruction pointer `%eip%`, чтобы он указывал на адрес вызываемой функции

Схематично:

{% highlight asm %}
pushl next_instruction_address
movl function_to_be_called_address, %eip
{% endhighlight %}

Таким образом, на момент вызова, стек выглядит следующим образом:

+ Return Address <-- %esp
+ Parameter 1
+ Parameter 2
+ ... 
+ Parameter N

#### Во время вызова
Как только началось выполнение тела функции, то необходимо опять совершить 2 действия:

1. Сохранить текущее значение base pointer регистра в стеке
2. Сохранить указатель на вершину стека в base pointer регистре

{% highlight asm %}
pushl %ebp
movl %esp, %ebp
{% endhighlight %}

Base pointer регистр - это специальный регистр, который позволяет достучаться до локальных переменных и параметров функции используя фиксированные смещения относительно него. Фактически, тот факт, что мы сохранили в нем значение `%esp` на момент вызова позволяет нам точно знать, где была вершина стека на момент вызова нашей функции, и так как возможен вызов функции внутри функции, то мы не можем использовать регистр `%esp` для этого т.к. стек будет обновлен при каждом последующем вызове.

Так получаем следующий стек:

+ Старое значение %ebp <-- %esp и %ebp
+ Return Address 4(%ebp)
+ Parameter 1 8(%ebp)
+ Parameter 2 12(%ebp)
+ ... 
+ Parameter N N*4 + 4(%ebp)

Затем можно зарезервировать нужное место для локальных переменных, чтобы они не перескались с последующим изменением стека, например, для того чтобы выделить место для 2-х слов:

{% highlight asm %}
subl $8, %esp
{% endhighlight %}

После чего стек примет следующий вид:

+ Локальная переменная 2 <-- %esp и -8(%ebp)
+ Локальная переменная 1 <-- -4(%ebp)
+ Старое значение %ebp <-- %ebp
+ Return Address 4(%ebp)
+ Parameter 1 8(%ebp)
+ Parameter 2 12(%ebp)
+ ... 
+ Parameter N N*4 + 4(%ebp)

Как можно заметить, использование `%ebp` регистра значительно упрощает жизнь, конечно, можно использовать любой другой регистр, но в этом и смысл соглашений, и кроме того, как говорится в книге(TODO: Проверить?) на x86 архитектуре работа с этим регистром в данном режиме, будет значительно быстрей.

Так как мы уже имеем доступ к локальным переменным, то остались глобальные и статические данные. Оказывается, ассемблеру в общем-то без разницы и доступ к ним, происходит точно также как доступ к данным из `.section .data` и разница появляется только в используемом языке.

#### После вызова
После окончания вызова, нам необходимо проделать следующее:

1. Сохранить возвращаемое значение в `%eax`
2. Вернуть стек к состоянию, которое было до вызова
3. Вернуть управление, к куску кода, который вызвал эту функцию. Делается это с помощью инструкции `ret`, которая вытаскивает верхний элемент из стека и устанавливает `%eip` в это значение.

Что в ассемблере реализуется следующим образом:

{% highlight asm %}
movl %ebp, %esp
popl %ebp
ret
{% endhighlight %}

И так как мы вернули стек назад, становится понятным, почему не стоит хранить/возвращать адреса на локальные переменные т.к мы по сути их отбросили и они, скорей всего, будут перезаписаны следующими вызовами.
